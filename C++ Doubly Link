/*
CCC121 Laboratory Exercise No. 1
Due: November 20, 2022 (Sunday) at 11:55PM
*/

// This is your first laboratory exercise for this class. This activity covers list ADT, array-based list, linked list, and doubly-linked list.

#include <iostream>
#include <assert.h>

using namespace std;

/*
The structure to be used for representing a doubly-linked link. This struct
declaration should not be modified in any way.
*/
template <class E>
struct DLink
{
    E theElement;       // data
    DLink<E> *nextPtr;  // pointer to next link
    DLink<E> *prevPtr;  // pointer to previous link
};

/*
Complete this implementation variant of the doubly-linked list. Use the same
convention as described in the slides. The DLink declaration to be used here is
just a struct and should not be modified in any way. All of the operations of
the original DLink class must be done in the methods of this class. Use
assertions to ensure the correct operation of this ADT. All memory allocations
should be checked with assertions and all discarded memory must be properly
deallocated.
*/
template <class E>
class DList
{
    DLink<E> *head; // pointer to first element of the list
    DLink<E> *tail; // pointer to last element of the list
    DLink<E> *curr; // pointer to current element of the list
    int cnt;        // number of elements in the list

public:
    // Return the size of the list
    int length() const
    {
        return cnt;
    }

    // The constructor with initial list size
    DList(int size)
    {
        this();
    }

    // DONE - NEEDS TO BE POLISHED
    // The default constructor
    DList()
    {
        head = new DLink<E>;        // allocating memory space for head ptr
        assert(head != nullptr);    // to check if the allocated head ptr contains an address

        tail = new DLink<E>;        // allocating memory space for tail ptr
        assert(tail != nullptr);    // to check if the allocated tail ptr contains an address

        head->prevPtr = nullptr;    // set the prevPtr of head to nullptr
        head->nextPtr = tail;       // set the nextPtr of head to tail
        
        tail->prevPtr = head;       // set the prevPtr of tail to head
        tail->nextPtr = nullptr;    // set the nextPtr of tail to nullptr
        
        curr = head;                // assign curr link to tail
        cnt = 0;                    // set cnt to zero
    }

    // REVIEW and REVISE
    // The copy constructor
    DList(const DList &source)
    {
        head = source->head;
        tail = source->tail;
        curr = source->curr;
        cnt = source->cnt;
    }

    // REVIEW and REVISE
    // The class destructor
    ~DList()
    {
        clear();

        delete head;
        delete tail;
    }

    // REVIEW and REVISE
    // Empty the list
    void clear()
    {
        moveToStart();                                  // to start from emptying the list from the curr link

        DLink<E> *temp = nullptr;                       //
        while(curr != tail)
        {
            temp = curr->nextPtr;
            delete curr;
            curr = temp;
        }
        curr = tail;
        head->nextPtr = tail;
        tail->prevPtr = head;
        cnt = 0;
    }

    // DONE - NEEDS TO BE POLISHED
    // Set current to first element
    void moveToStart()
    {
        curr = head->nextPtr;
    }

    // DONE - NEEDS TO BE POLISHED
    // Set current element to end of list
    void moveToEnd()
    {
        curr = tail->prevPtr;
    }

    // DONE - NEEDS TO BE POLISHED
    // Advance current to the next element
    void next()
    {
        curr = curr->nextPtr;
    }

    // DONE - NEEDS TO BE POLISHED
    // Return the current element
    E & getValue() const
    {
        // to check if the curr link contains an element and
        // if the condition is false an expression is executed
        assert(curr->nextPtr != nullptr);

        // return the element of the curr link
        return curr->nextPtr->theElement;
    }

    // DONE - NEEDS TO BE POLISHED
    // Insert value at current position
    void insert(const E &it)
    {
         DLink<E> *insertVal = new DLink<E>;            // create a link to insert
         assert(insertVal != nullptr);                  // to check if the allocated insertVal ptr contains an address

         insertVal->theElement = it;                    // assign 'it' value to the inserted link ptr

         insertVal->nextPtr = curr;                     // to set nextptr of insertVal to curr link

         insertVal->prevPtr = curr->nextPtr->prevPtr;   // to set prevPtr of insertVal to curr ptr

         curr->nextPtr->prevPtr = insertVal;            // to set the prevPtr of curr link to insertVal

         curr->nextPtr = insertVal;                     // to set nextPtr of curr ptr to insertVal

         curr = insertVal;                              // to assign curr link to insertVal

         cnt++;                                         // to increment cnt
    }

    // DONE - NEEDS TO BE POLISHED
    // Append value at the end of the list
    void append(const E &it)
    {
        DLink<E> *appendValue = new DLink<E>;           // create a link to append
        assert(appendValue != nullptr);                 // to check if the allocated appendValue ptr contains an address

        appendValue->theElement = it;                   // assign 'it' value to the appendValue ptr

        appendValue->nextPtr = tail;                    // set the nextptr of the appended value to tail

        appendValue->prevPtr = tail->prevPtr;           // set the prevPtr of the appended value to tail's prevPtr

        tail->prevPtr->nextPtr = appendValue;           // set the nextPtr of the tail's prevPtr to appendValue ptr

        tail->prevPtr = appendValue;                    // to set the prevPtr of tail to appendValue

        cnt++;                                          // increment cnt
    }

    // DONE - NEEDS TO BE POLISHED
    // Remove and return the current element
    E remove()
    {
        if(curr->nextPtr == tail)
        {
            return NULL;                                // nothing to remove
        }

        E it = curr->nextPtr->theElement;               // to remember the curr link's element

        DLink<E>* ltemp = curr->nextPtr;                // sets a temporary pointer to the link that will be removed
        assert(ltemp != nullptr);                       // to check if the allocated ltemp ptr contains an address

        curr->nextPtr->nextPtr->prevPtr = curr;         // makes the curr link's nextPtr's prevPtr points to the curr link that will be removed

        curr->nextPtr = curr->nextPtr->nextPtr;         // before deleting the ltemp pointer, we set the currPtr's nextPtr to the nextPtr of the curr link

        delete ltemp;                                   // to remove the curr element that is stored in ltemp ptr

        cnt--;                                          // decrement cnt

        return it;                                      // to return the current element
    }

    // DONE - NEEDS TO BE POLISHED
    // Advance current to the previous element
    void prev()
    {
        if(curr != head)                                // can't back up from list head
        {
            curr = curr->prevPtr;
        }
    }

    // DONE - NEEDS TO BE POLISHED
    // Return position of the current element
    int currPos() const
    {
        DLink<E> *temp = head->nextPtr;                 // create a temp ptr to assign the nextPtr of head

        int i;
        for(i=0; temp != curr; i++)
        {
            temp = temp->nextPtr;
        }
        return i;                                       // return the position of curr link
    }

    // DONE - NEEDS TO BE POLISHED
    // Set current to the element at the given position
    void moveToPos(int pos)
    {
        assert((pos>=0) && (pos<=cnt));                 // to check if the position is in the range of cnt
        curr = head->nextPtr;

        int i;
        for(i=0; i<pos; i++)
        {
            curr = curr->nextPtr;
        }
    }
};

/*
This is the main function for testing the implementation of the DList class.
This function can be freely modified.
*/
int main(void)
{
    int i;
    DList<int> theList;

    // populate the list
    for (i = 0; i < 10; ++i)
    {
        theList.append(i);
    }
    while (i < 20)
    {
        theList.insert(i);

        ++i;
    }

    // display the contents of the list
    theList.moveToStart();
    for (i = 0; i < theList.length(); ++i)
    {
        cout << theList.getValue() << " ";

        theList.next();
    }
    cout << "\n";

    // display the contents of the list in reverse order
    theList.moveToEnd();
    for (i = 0; i < theList.length(); ++i)
    {
        theList.prev();

        cout << theList.getValue() << " ";
    }
    cout << "\n";

    // replace the contents of the list
    theList.clear();
    for (i = 0; i < 10; ++i)
    {
        theList.append(i + 100);
    }

    // display the contents of the list
    theList.moveToStart();
    for (i = 0; i < theList.length(); ++i)
    {
        cout << theList.getValue() << " ";

        theList.next();
    }
    cout << "\n";

    // remove two elements at the specified position
    theList.moveToPos(5);
    cout << theList.currPos() << "\n";

    theList.remove();
    theList.remove();

    // display the contents of the list
    theList.moveToStart();
    for (i = 0; i < theList.length(); ++i)
    {
        cout << theList.getValue() << " ";

        theList.next();
    }
    cout << "\n";

    return 0;
}
